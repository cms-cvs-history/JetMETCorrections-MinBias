process PROD  = 
{

   service = MessageLogger
   {
      untracked vstring destinations = {"cout"}

      #vstring categories = { "FwkJob" }

      PSet cout = 
      {
         PSet default  = { int32 limit = 0 }  # kill all messages in the log
	 #PSet FwkJob   = { int32 limit = -1 } # but FwkJob category - those unlimitted
      }

      # uncomment if you want it...
      #
      # untracked vstring fwkJobReports = {"FrameworkJobReport.xml"}      
   }

   service = Timing {}
   
   service = RandomNumberGeneratorService
   {
      untracked uint32 sourceSeed = replace_by_per_job_attribute_#2#
      #untracked uint32 sourceSeed = 12
      PSet moduleSeeds =
      {
         untracked uint32 VtxSmeared = replace_by_per_job_attribute_#3#
	 #untracked uint32 VtxSmeared = 13
      }
   }

  #replace PythiaSource.maxEvents = 100
   
   # Step 1 : Event Generation
   source = PythiaSource
   {
      #untracked int32 maxEvents = 500
      untracked int32 maxEvents = 1
      untracked bool pythiaVerbosity = false

      PSet PythiaParameters =
      {

         # This is a vector of ParameterSet names to be read, in this order
         # The first two are in the include files below
         # The last one are simply my additional parameters
     vstring parameterSets =
     {
        "pythiaDefault",
        "myParameters"
     }

         # Default (mostly empty - to keep PYTHIA default) card file
         # Name of the set is "pythiaDefault"
         include "IOMC/GeneratorInterface/test/pythiaDefault.cfg"


         # User cards - name is "myParameters"
     vstring myParameters =
     {

	    'PMAS(32,1)= 700.            !mass of Zprime',
	    'MSEL=0                      !(D=1) to select between full user control (0, then use MSUB) and some preprogrammed alternative',
	    'MSTP(44) = 3                !only select the Z process',
   	    'MSUB(141) = 1               !ff  gamma z0 Z0',

            'MSTJ(11)=3                 ! Choice of the fragmentation function',
            'MSTJ(22)=2                 !Decay those unstable particles',
            'MSTP(2)=1                  !which order running alphaS',
            'MSTP(33)=0                 !(D=0) inclusion of K factors in (=0: none, i.e. K=1)',
            'MSTP(51)=7                 !structure function chosen',
            'MSTP(81)=1                 !multiple parton interactions 1 is Pythia default',
            'MSTP(82)=4                 !Defines the multi-parton model',
            'MSTU(21)=1                 !Check on possible errors during program execution',
            'PARJ(71)=10.               !for which ctau  10 mm',
            'PARP(82)=1.9               !pt cutoff for multiparton interactions',
            'PARP(89)=1000.             !sqrts for which PARP82 is set',
            'PARP(84)=0.4               !Multiple interactions: matter distribution Registered by Chris.Seez@cern.ch',
            'PARP(90)=0.16              !Multiple interactions: rescaling power Registered by Chris.Seez@cern.ch',
            'PMAS(5,1)=4.2              !mass of b quark',
            'PMAS(6,1)=175.             !mass of top quark',
            'PMAS(23,1)=91.187          !mass of Z',
            'PMAS(24,1)=80.22           !mass of W',

   	    'MDME(289,1)= 1            !d dbar',
   	    'MDME(290,1)= 1            !u ubar',
   	    'MDME(291,1)= 1            !s sbar',
   	    'MDME(292,1)= 1            !c cbar',
   	    'MDME(293,1)= 0            !b bar',
   	    'MDME(294,1)= 0            !t tbar',
   	    'MDME(295,1)= 0            !4th gen Q Qbar',
   	    'MDME(296,1)= 0            !4th gen Q Qbar',
   	    'MDME(297,1)= 0            !e e',
   	    'MDME(298,1)= 0            !neutrino e e',
   	    'MDME(299,1)= 0            ! mu mu',
   	    'MDME(300,1)= 0            !neutrino mu mu',
   	    'MDME(301,1)= 0            !tau tau',
   	    'MDME(302,1)= 0            !neutrino tau tau',
   	    'MDME(303,1)= 0            !4th generation lepton',
   	    'MDME(304,1)= 0            !4th generation neutrino',
   	    'MDME(305,1)= 0            !W W',
   	    'MDME(306,1)= 0            !H  charged higgs',
   	    'MDME(307,1)= 0            !Z',
   	    'MDME(308,1)= 0            !Z',
   	    'MDME(309,1)= 0            !sm higgs',
   	    'MDME(310,1)= 0            !weird neutral higgs HA'
         }

      }
   }
      
   # event vertex smearing - applies only once (internal check)
   # Note : all internal generatoes will always do (0,0,0) vertex
   #
   module VtxSmeared = VertexGenerator
   {
      string type = "IOMC/EventVertexGenerators/GaussianEventVertexGenerator"
      double MeanX = 0.
      double MeanY = 0.
      double MeanZ = 0.
      double SigmaX = 0.015
      double SigmaY = 0.015
      double SigmaZ = 53.0  // in mm (as in COBRA/OSCAR)
   }


   #Geometry
   #
   include "Geometry/CMSCommonData/data/cmsSimIdealGeometryXML.cfi"
   es_module = TrackerGeometricDetESModule {}
   es_module = TrackerDigiGeometryESModule {}
   
   # Magnetic Field
   #
   include "MagneticField/Engine/data/volumeBasedMagneticField.cfi"

   # Event, etc. output
   #
   module GEN-SIM = PoolOutputModule 
   { 
     untracked string fileName = "pythia_zprim_detsim.root" 
     untracked vstring outputCommands =
      {
        "keep *",
        "drop *_muoncscdigi_*_*",
        "drop *_muondtdigi_*_*",
        "drop *_stripdigi_*_*",
        "drop *_pixdigi_*_*",
        "drop *_ecaldigi_*_*",
        "drop *_SimG4Object_*_*"
      }
	
   }		
   # Geant4-based CMS Detector simulation
   #
   include "SimG4Core/Application/data/SimG4Object.cfi"
   
   # Step 3 : Digitization of the simulated hits
   #

   # Step 3a : Digitization of the Tracker
   #

   # required for Pixel and SiStrip Digitizers
   #

   # Pixel's digitization
   #
   include "SimTracker/SiPixelDigitizer/data/PixelDigi.cfi"

   # SiStrip's digitization
   #
   include "SimTracker/SiStripDigitizer/data/SiStripDigi.cfi"

   # Step 3b : Digitization of Ecal and Hcal

   # required for Ecal and Hcal Digitizers
   # NOTE : Both Ecal and Hcal geometries need to be present,
   #        even if only one digitizers is to run
   #
#
#   es_module = EcalPreshowerGeometryEP {}
#   es_module = EcalBarrelGeometryEP {}
#   es_module = EcalEndcapGeometryEP {}
#   es_module = HcalHardcodeGeometryEP {}
#   es_module = CaloTowerHardcodeGeometryEP {}
#   es_module = CaloGeometryBuilder {}
#   es_module = CaloTowerTopologyBuilder {}
#   es_module = HcalTopologyIdealEP {}
#   es_module = HcalDbProducer {}
#   es_source es_hardcode = HcalHardcodeCalibrations
#   {
#      untracked vstring toGet =
#      {
#         "Pedestals", "PedestalWidths",
#         "Gains", "GainWidths",
#         "QIEShape", "QIEData",
#         "ChannelQuality", "ElectronicsMap"
#      }
#   }

   es_module = EcalPreshowerGeometryEP {}
   es_module = EcalBarrelGeometryEP {}
   es_module = EcalEndcapGeometryEP {}
   es_module = HcalHardcodeGeometryEP {}
   es_module = CaloTowerHardcodeGeometryEP {}
   es_module = CaloGeometryBuilder {}
   es_module = CaloTowerConstituentsMapBuilder {
      untracked string MapFile="Geometry/CaloTopology/data/CaloTowerEEGeometric.map.gz"
   }
   es_module = HcalTopologyIdealEP {}
   es_module = HcalDbProducer {}
   es_source es_hardcode = HcalHardcodeCalibrations
   {
      untracked vstring toGet =
      {
         "Pedestals", "PedestalWidths",
         "Gains", "GainWidths",
         "QIEShape", "QIEData",
         "ChannelQuality", "ElectronicsMap"
      }
   }

   include "SimCalorimetry/EcalSimProducers/data/ecaldigi.cfi"
   
   include "SimCalorimetry/HcalSimProducers/data/hcaldigi.cfi"


   # Step 3c : Muon Digitization


   # this holds CSC geom service, as need for CSC digi's
   # and the digitizer itself
   #
   include "Geometry/CSCGeometry/data/cscGeometry.cfi"
   include "SimMuon/CSCDigitizer/data/muoncscdigi.cfi"

   # Muon DT digi's

   # this holds geom.service as needed by DT digi's
   # and the digitizer itself
   #
   include "Geometry/DTGeometry/data/dtGeometry.cfi"
   include "SimMuon/DTDigitizer/data/muondtdigi.cfi"

   # Mixing Module is *required* to simulated Ecal/Hcal/Muon digitization !

   module mix = MixingModule
   {
#      secsource input = PoolRASource
#      {
         #
         # starting 050, you can skip secsource block at all if you don't
         # wnat to model mixing/pileup at all;
         # however, an at least "empty mixing" need to be present if you
         # want to perform Ecal/Hcal/CSC/DT digitization - those explicitely
         # require presence of CrossingFrame in the edm::Event
         #
         # alternatively, you can set averageNumber=0 if you don't want
         # to model the pileup
         #
         # to the secsource/PoolRASource, you can give just 1 file or more;
         # this files will make a "concatinated buffer", which will go circular
         # until the loop of primary events is done - thus, it'll never run out
         #
         # WARNING: you can only give miltiple files, if they're generated with
         #          identical sets of tracked parameters;
         #          for example, you canNOT give a file made with a single muon
         #          gun and a file made with a single pion gun, because PartID
         #          is a *tracked* parameter in the gun's PSet;
         #          however, you can merge together files made with other generators,
         #          for example, PythiaSource, because all parameters of it would be
         #          *untracked*
         #
#         untracked vstring fileNames =
#         {'file:/afs/cern.ch/cms/geant4rep/genntpl/muon_simhit_for_pileup.060pre1.root' }
#         untracked vstring fileNames =
#         {'file:simevent.root' }
#         string type = "poisson"
#         double averageNumber = 3  # setting this param. to 0 means "No pile-up",
                                   # that is, digitize current crossing only
#         int32 minBunch = -3
#         int32 maxBunch = 5
#         int32 seed = 1234567
#      }
      int32 bunchspace = 25
   }


   #es_source = XMLIdealGeometryESSource 
   #{ 
   #   FileInPath GeometryConfiguration = "Geometry/CMSCommonData/data/simConfiguration.xml"
   #   #the proper root node is set in the xml file
   #   string rootNodeName = ""
   #}

#
# Calorimetry
#
###################################################################
 # Get hardcoded conditions the same used for standard digitization
  es_source = EcalTrivialConditionRetriever {
       #untracked double adcToGeVEBConstant = 0.0286
      untracked double adcToGeVEBConstant = 0.0636
  }
 ###################################################################


 #######################################################################################	
 # EB+EE uncalibrated RecHit producer 
 # Weight method (CMS standard requires tuned weights) 	
 include "RecoLocalCalo/EcalRecProducers/data/EcalWeightUncalibratedRecHitProducer.cfi"	
 # Analytic fit (much slower does not require weights) 	
 # include "RecoLocalCalo/EcalRecProducers/data/EcalAnalFitUncalibratedRecHitProducer.cfi"	
 #######################################################################################

 #######################################################################################
 # EB+EE RecHit producer (from uncalibrated RecHit)
 include "RecoLocalCalo/EcalRecProducers/data/EcalRecHitProducer.cfi"	
 #######################################################################################

 #######################################################################################
## ES RecHit producer (from Digis)
# include "RecoLocalCalo/EcalRecProducers/data/ESRecHitProducer.cfi"	
 #######################################################################################


   # HBHE rechit producer
   module hbheInput = HcalSimpleReconstructor {
          int32 firstSample = 4
          int32 samplesToAdd = 4
          string Subdetector = 'HBHE'
          string digiLabel = 'hcaldigi'
          bool correctForTimeslew = true
   }

   # HO rechit producer
   module hoInput = HcalSimpleReconstructor {
          int32 firstSample = 4
          int32 samplesToAdd = 4
          string Subdetector = 'HO'
          string digiLabel = 'hcaldigi'
          bool correctForTimeslew = true
   }

   # HF rechit producer
   module hfInput = HcalSimpleReconstructor {
          int32 firstSample = 2
          int32 samplesToAdd = 2
          string Subdetector = 'HF'
          string digiLabel = 'hcaldigi'
          bool correctForTimeslew = true
   }


# this one makes CaloTowers
   module towermaker = CaloTowersCreator {
      double HBThreshold = 0.9     // GeV, Scheme B
      double HOThreshold = 1.1     // GeV, Scheme B
      double HESThreshold = 1.4    // GeV, Scheme B
      double HEDThreshold = 1.4    // GeV, Scheme B
      double HF1Threshold = 0.5    // GeV, ORCA value
      double HF2Threshold = 0.5    // GeV, ORCA value
      double EBThreshold = 0.09    // GeV, ORCA value w/o selective readout
      double EEThreshold = 0.45    // GeV, ORCA value w/o selective readout
      
      double EBSumThreshold = 0.2  // GeV, Scheme B
      double EESumThreshold = 0.45 // GeV, Scheme B
      double HcalThreshold = -1000 // GeV, -1000 means cut not used 
      double EcutTower = -1000     // GeV, -1000 means cut not used
      double EBWeight = 1.0
      double EEWeight = 1.0
      double HBWeight = 1.0
      double HESWeight = 1.0
      double HEDWeight = 1.0
      double HOWeight = 1.0
      double HF1Weight = 1.0
      double HF2Weight = 1.0
      bool UseHO = true
      string hbheInput = "recohbhe"
      string hoInput = "recoho"
      string hfInput = "recohf"
      vstring ecalInputs = {"ecalrechit/EcalRecHitsEB"}
      untracked bool AllowMissingInputs = true
   }
# this one makes candidates from CaloTowers
   module caloTowers = CaloTowerCandidateCreator {
          string src = "towermaker"
          double minimumEt = -1
          double minimumE = -1
   }
    module myanalysis = MinBias {

# names of modules, producing object collections

      string hbheInput = "hbheInput"   
      string hoInput = "hoInput"
      string hfInput = "hfInput"
# name of output root file with histograms
      untracked string HistOutFile = "analysis.replace_by_per_job_attribute_#1#.root"	

    }

   sequence trDigi = { pixdigi & stripdigi }
   sequence calDigi = { ecaldigi & hcaldigi }
   sequence muonDigi = { muoncscdigi & muondtdigi }
   sequence doDigi = { trDigi & calDigi & muonDigi  }
   sequence doHReco  = { hbheInput, hoInput, hfInput }

   # now the order of execution
   #
   path p1 = { VtxSmeared, SimG4Object, mix, doDigi, doHReco, myanalysis }
   endpath outpath = { GEN-SIM }
   
}		
