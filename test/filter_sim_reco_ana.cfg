process PROD  = 
{

   service = MessageLogger
   {
      untracked vstring destinations = {"cout"}

      #vstring categories = { "FwkJob" }

      PSet cout = 
      {
         PSet default  = { int32 limit = 0 }  # kill all messages in the log
	 #PSet FwkJob   = { int32 limit = -1 } # but FwkJob category - those unlimitted
      }

      # uncomment if you want it...
      #
      # untracked vstring fwkJobReports = {"FrameworkJobReport.xml"}      
   }

   service = Timing {}
   
   service = RandomNumberGeneratorService
   {
      untracked uint32 sourceSeed = 123456789
      PSet moduleSeeds =
      {
         untracked uint32 VtxSmeared = 987654321
      }
   }

   #include "JetMETCorrections/MinBias/data/PythiaSourceDiJetsSingleJet.cfi"
   #replace PythiaSource.maxEvents = 100
   
source = PythiaSource 
{ 
  untracked int32 maxEvents = 100
  untracked bool pythiaVerbosity = false
  untracked uint32 numberEventsInRun = 1
  untracked string selectType = "SingleJet"
  
  PSet PythiaParameters = {

    # This is a vector of ParameterSet names to be read, in this order
    # The first two are in the include files below
    # The last one are simply my additional parameters
    vstring parameterSets = {
      "pythiaDefault", 
      "pythiaDiJets", 
      "myParameters"
    }

    # Default (mostly empty - to keep PYTHIA default) card file
    # Name of the set is "pythiaDefault"
include "IOMC/GeneratorInterface/data/pythiaDefault.cff"


    vstring pythiaDiJets = {
      'MSEL=0         ! User defined processes',
      'MSUB(11)=1     ! Min bias process',
      'MSUB(12)=1     ! Min bias process',
      'MSUB(13)=1     ! Min bias process',
      'MSUB(14)=1     ! Min bias process',
      'MSUB(15)=1     ! Min bias process',
      'MSUB(16)=1     ! Min bias process',
      'MSUB(28)=1     ! Min bias process',
      'MSUB(29)=1     ! Min bias process',
      'MSUB(30)=1     ! Min bias process',
      'MSUB(31)=1     ! Min bias process',      
      'MSUB(53)=1     ! Min bias process',
      'MSUB(68)=1     ! Min bias process',
      'MSTJ(11)=3     ! Choice of the fragmentation function',
      'MSTJ(22)=2     ! Decay those unstable particles',
      'PARJ(71)=10.   ! for which ctau  10 mm',
      'MSTP(2)=1      ! which order running alphaS',
      'MSTP(33)=0     ! no K factors in hard cross sections',
      'MSTP(51)=7     ! structure function chosen',
      'MSTP(81)=1     ! multiple parton interactions 1 is Pythia default',
      'MSTP(82)=4     ! Defines the multi-parton model',
      'MSTU(21)=1     ! Check on possible errors during program execution',
      'PARP(82)=1.9   ! pt cutoff for multiparton interactions',
      'PARP(89)=1000. ! sqrts for which PARP82 is set',
      'PARP(83)=0.5   ! Multiple interactions: matter distrbn parameter',
      'PARP(84)=0.4   ! Multiple interactions: matter distribution parameter',
      'PARP(90)=0.16  ! Multiple interactions: rescaling power',
      'PARP(67)=1.    ! amount of initial-state radiation',
      'PARP(85)=0.33  ! gluon prod. mechanism in MI',
      'PARP(86)=0.66  ! gluon prod. mechanism in MI',
      'PARP(87)=0.7   ! ',
      'PARP(88)=0.5   ! ',
      'PARP(91)=1.0   ! kt distribution',
      'CKIN(3)=115.     ! Pthat_min',
      'CKIN(4)=125.     ! Pthat_max'
    }

    # User cards - name is "myParameters"
    # Pythia's random generator initialization 
    vstring myParameters = {
    #'MRPY(1)=-1     ! Random initizaliation (negative=really random)'
    #  'MRPY(1)= 123456789 ! Automatically random if -1'
    }
  }
}
   module filter = PythiaSingleJetFilter
   {
       untracked string moduleLabel = 'source'
       untracked double MinJetPtCut = 115.
       untracked double MaxJetPtCut = 125.
       untracked double MinJetEtaCut = -0.3
       untracked double MaxJetEtaCut = 0.3
       untracked uint32 MaxNumberOfEventsInRun = 1
   }
   
   # event vertex smearing - applies only once (internal check)
   # Note : all internal generatoes will always do (0,0,0) vertex
   #
   module VtxSmeared = VertexGenerator
   {
      string type = "IOMC/EventVertexGenerators/GaussianEventVertexGenerator"
      double MeanX = 0.
      double MeanY = 0.
      double MeanZ = 0.
      double SigmaX = 0.015
      double SigmaY = 0.015
      double SigmaZ = 53.0  // in mm (as in COBRA/OSCAR)
   }


   #Geometry
   #
   include "Geometry/CMSCommonData/data/cmsSimIdealGeometryXML.cfi"
   es_module = TrackerGeometricDetESModule {}
   es_module = TrackerDigiGeometryESModule {}
   
   # Magnetic Field
   #
   include "MagneticField/Engine/data/volumeBasedMagneticField.cfi"

   # Event, etc. output
   #
   module GEN-SIM = PoolOutputModule 
   { 
     untracked string fileName = "pythia_minbias_detsim.root" 
        untracked PSet SelectEvents = {
           vstring SelectEvents = {"p1"}
        }
   untracked vstring outputCommands =
     {
      "keep *",
      "drop *_muonCSCDigis_*_*",
      "drop *_muonDTDigis_*_*",
      "drop *_siStripDigis_*_*",
      "drop *_siPixelDigis_*_*",
      "drop *_hcalDigis_*_*",
      "drop *_ecalUnsuppressedDigis_*_*",
      "drop *_g4SimHits_*_*"
      }
	
   }
    untracked PSet options = {
        untracked bool makeTriggerResults = true
        vstring listOfTriggers = {"*"}
        untracked vstring Rethrow = {"endJob"}
    }
		
   # Geant4-based CMS Detector simulation
   #
   include "SimG4Core/Application/data/SimG4Object.cfi"
   
   # Step 3 : Digitization of the simulated hits
   #

   # Step 3a : Digitization of the Tracker
   #

   # required for Pixel and SiStrip Digitizers
   #

   # Pixel's digitization
   #
   include "SimTracker/SiPixelDigitizer/data/PixelDigi.cfi"

   # SiStrip's digitization
   #
   include "SimTracker/SiStripDigitizer/data/SiStripDigi.cfi"

   # Step 3b : Digitization of Ecal and Hcal

   # required for Ecal and Hcal Digitizers
   # NOTE : Both Ecal and Hcal geometries need to be present,
   #        even if only one digitizers is to run
   #
#
#   es_module = EcalPreshowerGeometryEP {}
#   es_module = EcalBarrelGeometryEP {}
#   es_module = EcalEndcapGeometryEP {}
#   es_module = HcalHardcodeGeometryEP {}
#   es_module = CaloTowerHardcodeGeometryEP {}
#   es_module = CaloGeometryBuilder {}
#   es_module = CaloTowerTopologyBuilder {}
#   es_module = HcalTopologyIdealEP {}
#   es_module = HcalDbProducer {}
#   es_source es_hardcode = HcalHardcodeCalibrations
#   {
#      untracked vstring toGet =
#      {
#         "Pedestals", "PedestalWidths",
#         "Gains", "GainWidths",
#         "QIEShape", "QIEData",
#         "ChannelQuality", "ElectronicsMap"
#      }
#   }

   es_module = EcalPreshowerGeometryEP {}
   es_module = EcalBarrelGeometryEP {}
   es_module = EcalEndcapGeometryEP {}
   es_module = HcalHardcodeGeometryEP {}
   es_module = CaloTowerHardcodeGeometryEP {}
   es_module = CaloGeometryBuilder {}
   es_module = CaloTowerConstituentsMapBuilder {
      untracked string MapFile="Geometry/CaloTopology/data/CaloTowerEEGeometric.map.gz"
   }
   es_module = HcalTopologyIdealEP {}
   es_module = HcalDbProducer {}
   es_source es_hardcode = HcalHardcodeCalibrations
   {
      untracked vstring toGet =
      {
         "Pedestals", "PedestalWidths",
         "Gains", "GainWidths",
         "QIEShape", "QIEData",
         "ChannelQuality", "ElectronicsMap"
      }
   }

   include "SimCalorimetry/EcalSimProducers/data/ecaldigi.cfi"
   
   include "SimCalorimetry/HcalSimProducers/data/hcaldigi.cfi"


   # Step 3c : Muon Digitization


   # this holds CSC geom service, as need for CSC digi's
   # and the digitizer itself
   #
   include "Geometry/CSCGeometry/data/cscGeometry.cfi"
   include "SimMuon/CSCDigitizer/data/muoncscdigi.cfi"

   # Muon DT digi's

   # this holds geom.service as needed by DT digi's
   # and the digitizer itself
   #
   include "Geometry/DTGeometry/data/dtGeometry.cfi"
   include "SimMuon/DTDigitizer/data/muondtdigi.cfi"

   # Mixing Module is *required* to simulated Ecal/Hcal/Muon digitization !

   module mix = MixingModule
   {
#      secsource input = PoolRASource
#      {
         #
         # starting 050, you can skip secsource block at all if you don't
         # wnat to model mixing/pileup at all;
         # however, an at least "empty mixing" need to be present if you
         # want to perform Ecal/Hcal/CSC/DT digitization - those explicitely
         # require presence of CrossingFrame in the edm::Event
         #
         # alternatively, you can set averageNumber=0 if you don't want
         # to model the pileup
         #
         # to the secsource/PoolRASource, you can give just 1 file or more;
         # this files will make a "concatinated buffer", which will go circular
         # until the loop of primary events is done - thus, it'll never run out
         #
         # WARNING: you can only give miltiple files, if they're generated with
         #          identical sets of tracked parameters;
         #          for example, you canNOT give a file made with a single muon
         #          gun and a file made with a single pion gun, because PartID
         #          is a *tracked* parameter in the gun's PSet;
         #          however, you can merge together files made with other generators,
         #          for example, PythiaSource, because all parameters of it would be
         #          *untracked*
         #
#         untracked vstring fileNames =
#         {'file:/afs/cern.ch/cms/geant4rep/genntpl/muon_simhit_for_pileup.060pre1.root' }
#         untracked vstring fileNames =
#         {'file:simevent.root' }
#         string type = "poisson"
#         double averageNumber = 3  # setting this param. to 0 means "No pile-up",
                                   # that is, digitize current crossing only
#         int32 minBunch = -3
#         int32 maxBunch = 5
#         int32 seed = 1234567
#      }
      int32 bunchspace = 25
   }


   #es_source = XMLIdealGeometryESSource 
   #{ 
   #   FileInPath GeometryConfiguration = "Geometry/CMSCommonData/data/simConfiguration.xml"
   #   #the proper root node is set in the xml file
   #   string rootNodeName = ""
   #}

#
# Calorimetry
#
###################################################################
 # Get hardcoded conditions the same used for standard digitization
  es_source = EcalTrivialConditionRetriever {
       #untracked double adcToGeVEBConstant = 0.0286
      untracked double adcToGeVEBConstant = 0.0636
  }
 ###################################################################


 #######################################################################################	
 # EB+EE uncalibrated RecHit producer 
 # Weight method (CMS standard requires tuned weights) 	
 include "RecoLocalCalo/EcalRecProducers/data/EcalWeightUncalibratedRecHitProducer.cfi"	
 # Analytic fit (much slower does not require weights) 	
 # include "RecoLocalCalo/EcalRecProducers/data/EcalAnalFitUncalibratedRecHitProducer.cfi"	
 #######################################################################################

 #######################################################################################
 # EB+EE RecHit producer (from uncalibrated RecHit)
 include "RecoLocalCalo/EcalRecProducers/data/EcalRecHitProducer.cfi"	
 #######################################################################################

 #######################################################################################
## ES RecHit producer (from Digis)
# include "RecoLocalCalo/EcalRecProducers/data/ESRecHitProducer.cfi"	
 #######################################################################################


   # HBHE rechit producer
   module hbheInput = HcalSimpleReconstructor {
          int32 firstSample = 4
          int32 samplesToAdd = 4
          string Subdetector = 'HBHE'
          string digiLabel = 'hcalDigis'
          bool correctForTimeslew = true
   }

   # HO rechit producer
   module hoInput = HcalSimpleReconstructor {
          int32 firstSample = 4
          int32 samplesToAdd = 4
          string Subdetector = 'HO'
          string digiLabel = 'hcalDigis'
          bool correctForTimeslew = true
   }

   # HF rechit producer
   module hfInput = HcalSimpleReconstructor {
          int32 firstSample = 2
          int32 samplesToAdd = 2
          string Subdetector = 'HF'
          string digiLabel = 'hcalDigis'
          bool correctForTimeslew = true
   }


# this one makes CaloTowers
   module towermaker = CaloTowersCreator {
      double HBThreshold = 0.9     // GeV, Scheme B
      double HOThreshold = 1.1     // GeV, Scheme B
      double HESThreshold = 1.4    // GeV, Scheme B
      double HEDThreshold = 1.4    // GeV, Scheme B
      double HF1Threshold = 0.5    // GeV, ORCA value
      double HF2Threshold = 0.5    // GeV, ORCA value
      double EBThreshold = 0.09    // GeV, ORCA value w/o selective readout
      double EEThreshold = 0.45    // GeV, ORCA value w/o selective readout
      
      double EBSumThreshold = 0.2  // GeV, Scheme B
      double EESumThreshold = 0.45 // GeV, Scheme B
      double HcalThreshold = -1000 // GeV, -1000 means cut not used 
      double EcutTower = -1000     // GeV, -1000 means cut not used
      double EBWeight = 1.0
      double EEWeight = 1.0
      double HBWeight = 1.0
      double HESWeight = 1.0
      double HEDWeight = 1.0
      double HOWeight = 1.0
      double HF1Weight = 1.0
      double HF2Weight = 1.0
      bool UseHO = true
      string hbheInput = "recohbhe"
      string hoInput = "recoho"
      string hfInput = "recohf"
      vstring ecalInputs = {"ecalrechit/EcalRecHitsEB"}
      untracked bool AllowMissingInputs = true
   }
# this one makes candidates from CaloTowers
   module caloTowers = CaloTowerCandidateCreator {
          string src = "towermaker"
          double minimumEt = -1
          double minimumE = -1
   }
    module myanalysis = MinBias {

# names of modules, producing object collections

      string hbheInput = "hbheInput"   
      string hoInput = "hoInput"
      string hfInput = "hfInput"
# name of output root file with histograms
      untracked string HistOutFile = "analysis.root"	

    }

   sequence trDigi = {  siPixelDigis & siStripDigis }
   sequence calDigi = { ecalUnsuppressedDigis & hcalDigis }
   sequence muonDigi = { muonCSCDigis &  muonDTDigis }
   sequence doDigi = { trDigi & calDigi & muonDigi  }
   sequence doHReco  = { hbheInput, hoInput, hfInput }

   # now the order of execution
   #
   path p1 = { filter, VtxSmeared, g4SimHits, mix, doDigi, doHReco, myanalysis }
   endpath outpath = { GEN-SIM }
   
}		
